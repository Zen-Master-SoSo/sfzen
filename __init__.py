#  sfzen/__init__.py
#
#  Copyright 2024 liyang <liyang@veronica>
#
"""
Simple object-oriented SFZ parsing and manipulation.
"""
import logging, re
from os import mkdir
from os.path import abspath, basename, dirname, join, splitext, exists
from operator import or_
from functools import reduce
from collections import defaultdict
from appdirs import user_cache_dir
from lark import Lark, Transformer, v_args
from lark.tree import Meta
from good_logging import log_error
from sfzen.sfz_elems import (
	_SFZElement,
	_Header,
	_Modifier,
	Global,
	Master,
	Group,
	Region,
	Control,
	Effect,
	Midi,
	Curve,
	Opcode,
	Sample,
	Define,
	Include
)
from sfzen.sort import midi_key_sort

COMMENT_DIVIDER = '// ' + '-' * 76 + "\n"

SAMPLES_ABSPATH				= 0
SAMPLES_RESOLVE				= 1
SAMPLES_COPY				= 2
SAMPLES_SYMLINK				= 3
SAMPLES_HARDLINK			= 4


KEY_OPCODES = ['lokey', 'hikey', 'pitch_keycenter']
LOOP_DEFINITION_OPCODES = [
	'egN_loop',
	'egN_loop_count',
	'loop_count',
	'loop_crossfade',
	'loop_end',
	'loop_length_onccN',
	'loop_lengthccN',
	'loop_mode',
	'loop_start',
	'loop_start_onccN',
	'loop_startccN',
	'loop_tune',
	'loop_type',
	'loopcount',
	'loopend',
	'loopmode',
	'loopstart',
	'looptune',
	'looptype'
]

class SFZXformer(Transformer):
	"""
	Takes the parse tree generated by lark and generates an SFZ object.
	"""

	def __init__(self, sfz):
		self.sfz = sfz
		self.current_header = self.sfz

	@v_args(meta=True)
	def header(self, arg1, arg2):
		"""
		Transformer function which handles <header> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		if toks[0].value == 'region':
			header = Region(toks, meta)
		elif toks[0].value == 'group':
			header = Group(toks, meta)
		elif toks[0].value == 'control':
			header = Control(toks, meta)
		elif toks[0].value == 'global':
			header = Global(toks, meta)
		elif toks[0].value == 'curve':
			header = Curve(toks, meta)
		elif toks[0].value == 'effect':
			header = Effect(toks, meta)
		elif toks[0].value == 'master':
			header = Master(toks, meta)
		elif toks[0].value == 'midi':
			header = Midi(toks, meta)
		while not self.current_header.may_contain(header):
			self.current_header = self.current_header.parent
		self.current_header.append_subheader(header)
		self.current_header = header

	@v_args(meta=True)
	def define_macro(self, arg1, arg2):
		"""
		Transformer function which handles <define> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		try:
			self.sfz.defines[toks[0].value] = Define(toks[0].value, toks[1].value, meta)
		except Exception as e:
			self.sfz.append_parse_error(e, meta)

	@v_args(meta=True)
	def include_macro(self, arg1, arg2):
		"""
		Transformer function which handles <include> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		try:
			include = Include(self.unquote(self.replace_defs(toks[0].value)), meta)
			self.sfz.includes.append(include)
			path = join(dirname(self.sfz.filename), include.filename)
			if exists(path):
				logging.debug('Including "%s"', path)
				try:
					subsfz = SFZ(path, defines = self.sfz.defines, basedir = self.sfz.basedir, is_include = True)
					for header in subsfz.subheadings:
						while not self.current_header.may_contain(header):
							self.current_header = self.current_header.parent
						self.current_header.append_subheader(header)
						self.current_header = header
					self.sfz.defines = subsfz.defines
					self.sfz.includes.extend(subsfz.includes)
				except Exception as e:
					log_error(e)
			else:
				raise ValueError('Include not found: %s' % path)
		except Exception as e:
			self.sfz.append_parse_error(e, meta)

	@v_args(meta=True)
	def opcode_exp(self, arg1, arg2):
		"""
		Transformer function which handles <opcode> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		try:
			if isinstance(self.current_header, Curve):
				if toks[0] == 'curve_index':
					self.current_header.curve_index = toks[1].value
				else:
					if re.match(r'v(\d+)', toks[0].value):
						self.current_header.points[toks[0].value] = toks[1].value
					else:
						logging.error('Invalid opcode inside velocity curve definition')
			else:
				opname = self.replace_defs(toks[0].value.lower())
				if opname == 'sample':
					self.current_header.append_opcode(Sample(
						opname, self.replace_defs(toks[1].value),
						meta, self.sfz.basedir))
				else:
					self.current_header.append_opcode(Opcode(
						opname, self.replace_defs(toks[1].value), meta))
		except Exception as e:
			self.sfz.append_parse_error(e, meta)

	@v_args(meta=True)
	def start(self, arg1, arg2):
		"""
		Transformer function which handles the root of the sfz.
		"""

	def wonky_lark_args(self, arg1, arg2):
		"""
		When @v_args decorates a lark.Transformer function, lark passes parsed tokens
		and meta info to the function. Different versions of lark parser seem to pass
		the tokens and meta arguments in different order. This function fixes that.
		"""
		if isinstance(arg1, Meta):
			return arg1, arg2
		return arg2, arg1

	def replace_defs(self, var):
		"""
		Replace defined variable with the value that it has been defined as in the sfz.
		"""
		return re.sub(r'\$(\w+)', lambda v: self.sfz.defines[v.group(1)].value, var)

	def unquote(self, var):
		"""
		Remove quotes around a parsed value.
		"""
		for q in ["'", '"']:
			if var[0] == q and var[-1] == q:
				return var[1:-1]
		return var


class SFZ(_Header):
	"""
	Provides an object-oriented interface to an .sfz file.
	"""

	_parser = None

	def __init__(self, filename = None, defines = {}, basedir = None, is_include = False):
		"""
		filename: (str) Path to an .sfz file.

		Passing "defines" allows us to construct an SFZ which is an import, and use the
		defined variables from the parent SFZ.

		Passing "basedir" allows included SFZ parts to use the directory of their
		parent when parsing sample paths.
		"""
		self.filename = filename
		self.defines = defines
		self.is_include = is_include
		self._parent = None
		self._subheadings = []
		self._opcodes = {}
		self.includes = []
		self.parse_errors = []
		if filename is None:
			self.name = '[unnamed SFZ]'
			self.basedir = None
		else:
			self.name = basename(filename)
			self.basedir = dirname(self.filename) if basedir is None else basedir
			if SFZ._parser is None:
				cache_file = join(user_cache_dir(), 'sfzen')
				grammar = join(dirname(__file__), 'res', 'sfz.lark')
				SFZ._parser = Lark.open(grammar, parser='lalr', propagate_positions=True, cache=cache_file)
			with open(filename) as f:
				tree = SFZ._parser.parse(f.read() + "\n")
			xformer = SFZXformer(self)
			xformer.transform(tree)

	def may_contain(self, header):
		return True

	def append_opcode(self, opcode):
		if not self.is_include:
			raise RuntimeError("Opcode outside of header")
		super().append_opcode(opcode)

	def append_subheader(self, subheading):
		self._subheadings.append(subheading)
		subheading.parent = self

	def append_parse_error(self, error, meta):
		tb = error.__traceback__
		logging.error('Parse error in %s line %d: %s "%s" in %s, line %s',
			self.filename,
			meta.line,
			type(error).__name__,
			str(error),
			basename(tb.tb_frame.f_code.co_filename),
			tb.tb_lineno
		)
		self.parse_errors.append(error)

	def inherited_opcodes(self):
		return {}

	def headers(self):
		"""
		Returns a list of headers which are immediate children of this SFZ.
		"""
		return self._subheadings

	def samples(self):
		"""
		Generator which yields a Sample object on each iteraration.
		"""
		for header in self._subheadings:
			yield from header.samples()

	def opcodes_used(self):
		"""
		Returns a set of the keys of all the opcodes used in this SFZ.
		"""
		return reduce(or_, [heading.opcodes_used() for heading in self._subheadings], set())

	def regions_for(self, key=None, lokey=None, hikey=None, lovel=None, hivel=None):
		"""
		Generator function which yields each region contained in this SFZ which matches
		the given criteria.
		For example, to get every region which plays Middle C at any velocity:
			sfz.regions_for(lokey = 60, hikey = 60)
		"""
		for region in self.regions():
			if region.is_triggerd_by(key, lokey, hikey, lovel, hivel):
				yield region

	def save_as(self, filename, samples_mode = SAMPLES_ABSPATH):
		"""
		Save to the given filename.

		"samples_mode" is a constant which defines how to render "sample"
		opcodes. May be one of:

			SAMPLES_ABSPATH		SAMPLES_RESOLVE		SAMPLES_COPY
			SAMPLES_SYMLINK		SAMPLES_HARDLINK

		"""
		filename = abspath(filename)
		target_sfz_dir = dirname(filename)
		filetitle, ext = splitext(basename(filename))
		try:
			mkdir(target_sfz_dir)
		except FileExistsError:
			pass
		if samples_mode == SAMPLES_ABSPATH:
			for sample in self.samples():
				sample.use_abspath()
		elif samples_mode == SAMPLES_RESOLVE:
			for sample in self.samples():
				sample.resolve_from(target_sfz_dir)
		else:
			samples_path = filetitle + '-samples'
			try:
				mkdir(join(target_sfz_dir, samples_path))
			except FileExistsError:
				pass
			for sample in self.samples():
				try:
					if samples_mode == SAMPLES_COPY:
						sample.copy_to(target_sfz_dir, samples_path)
					elif samples_mode == SAMPLES_SYMLINK:
						sample.symlink_to(target_sfz_dir, samples_path)
					elif samples_mode == SAMPLES_HARDLINK:
						sample.hardlink_to(target_sfz_dir, samples_path)
				except FileExistsError:
					pass
		with open(filename + '.sfz' if ext == '' else filename,
			'w', encoding = 'utf-8') as fob:
			self.write(fob)

	def write(self, stream):
		"""
		Exports this SFZ to .sfz format.
		"stream" may be any file-like object, including sys.stdout.
		"""
		stream.write(f'{COMMENT_DIVIDER}// {self.filename}\n{COMMENT_DIVIDER}\n')
		for sub in self._subheadings:
			sub.write(stream)

	def simplified(self):
		"""
		Returns an equivalent SFZ with common opcodes grouped, and opcodes using the
		default value skipped.
		"""
		sfz = SFZ()
		for region in [
			self._clone_sample_region(sample) \
			for sample in self.samples() ]:
			sfz.append_subheader(region)
		# Condense "lokey", "hikey", "pitch_keycenter"
		for sub in sfz._subheadings:
			key_related_values = [
				opcode.value for opcode in sub.opcodes.values() \
				if opcode.name in KEY_OPCODES
			]
			if len(key_related_values) == 3 and len(set(key_related_values)) == 1:
				for opcode_name in KEY_OPCODES:
					del sub._opcodes[opcode_name]
				sub.append_opcode(Opcode('key', key_related_values[0], None))
		# Remove loop-related opcodes for regions that are not looped:
		for sub in sfz._subheadings:
			loopmode = sub.opcode('loop_mode') or sub.opcode('loopmode')
			if loopmode and loopmode.value == 'no_loop':
				for opcode_name in LOOP_DEFINITION_OPCODES:
					try:
						del sub._opcodes[opcode_name]
					except KeyError:
						pass
		# Sort in key order:
		sfz._subheadings.sort(key = midi_key_sort)
		# Filter global opstrings:
		common_opstrings = sfz.common_opstrings()
		global_header = None
		if len(common_opstrings):
			global_header = Global(None, None)
			for tup in [ opstring.split('=', 1) for opstring in common_opstrings ]:
				global_header.append_opcode(Opcode(tup[0], tup[1], None))
				for sub in sfz._subheadings:
					del sub._opcodes[tup[0]]
			# Defer inserting global header until AFTER grouping!!!
		# Group regions based on common key:
		key_regions = defaultdict(list)
		for sub in sfz._subheadings:
			key_regions[sub.opcode('key')].append(sub)
		# Deferred insert global header:
		if global_header:
			sfz._subheadings.insert(0, global_header)
		return sfz

	def _clone_sample_region(self, sample):
		region = Region(None, None)
		for opcode in sample.parent.inherited_opcodes().values():
			region.append_opcode(opcode)
		return region

	def dump(self):
		"""
		Print (to stdout) a concise outline of this SFZ.
		"""
		for elem, depth in self.walk():
			print('  ' * depth, end="")
			print(repr(elem))

	def __repr__(self):
		return f'SFZ {self.filename}'


#  end sfzen/__init__.py
