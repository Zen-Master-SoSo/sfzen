#  sfzen/__init__.py
#
#  Copyright 2024 liyang <liyang@veronica>
#
import os, logging, re
from operator import or_
from functools import reduce
from appdirs import user_cache_dir
from lark import Lark, Transformer, v_args
from lark.tree import Meta
from good_logging import log_error
from sfzen.sfz_elems import (
	_SFZElement,
	_Header,
	_Modifier,
	Global,
	Master,
	Group,
	Region,
	Control,
	Effect,
	Midi,
	Curve,
	Opcode,
	Sample,
	Define,
	Include
)

COMMENT_DIVIDER = '// ' + '-' * 76 + "\n"


class SFZXformer(Transformer):
	"""
	Takes the parse tree generated by lark and generates an SFZ object.
	"""

	def __init__(self, sfz):
		self.sfz = sfz
		self.current_header = self.sfz

	@v_args(meta=True)
	def header(self, arg1, arg2):
		"""
		Transformer function which handles <header> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		if toks[0].value == 'region':
			header = Region(toks, meta)
		elif toks[0].value == 'group':
			header = Group(toks, meta)
		elif toks[0].value == 'control':
			header = Control(toks, meta)
		elif toks[0].value == 'global':
			header = Global(toks, meta)
		elif toks[0].value == 'curve':
			header = Curve(toks, meta)
		elif toks[0].value == 'effect':
			header = Effect(toks, meta)
		elif toks[0].value == 'master':
			header = Master(toks, meta)
		elif toks[0].value == 'midi':
			header = Midi(toks, meta)
		while not self.current_header.may_contain(header):
			self.current_header = self.current_header.parent
		self.current_header.append_subheader(header)
		self.current_header = header

	@v_args(meta=True)
	def define_macro(self, arg1, arg2):
		"""
		Transformer function which handles <define> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		self.sfz.defines[toks[0].value] = Define(toks[0].value, toks[1].value, meta)

	@v_args(meta=True)
	def include_macro(self, arg1, arg2):
		"""
		Transformer function which handles <include> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		include = Include(self.unquote(self.replace_defs(toks[0].value)), meta)
		self.sfz.includes.append(include)
		path = os.path.join(os.path.dirname(self.sfz.filename), include.filename)
		if os.path.exists(path):
			logging.debug('Including "%s"', path)
			try:
				subsfz = SFZ(path, defines=self.sfz.defines)
				for header in subsfz.subheaders:
					while not self.current_header.may_contain(header):
						self.current_header = self.current_header.parent
					self.current_header.append_subheader(header)
					self.current_header = header
				self.sfz.defines = subsfz.defines
				self.sfz.includes.extend(subsfz.includes)
			except Exception as e:
				log_error(e)


	@v_args(meta=True)
	def opcode_exp(self, arg1, arg2):
		"""
		Transformer function which handles <opcode> tokens.
		"""
		meta, toks = self.wonky_lark_args(arg1, arg2)
		if isinstance(self.current_header, Curve):
			if toks[0] == 'curve_index':
				self.current_header.curve_index = toks[1].value
			else:
				match = re.match(r'v(\d+)', toks[0].value)
				if match:
					self.current_header.points[toks[0].value] = toks[1].value
				else:
					logging.error('Invalid opcode inside velocity curve definition')
		else:
			opname = self.replace_defs(toks[0].value.lower())
			if opname == 'sample':
				self.current_header.append_opcode(Sample(
					opname, self.replace_defs(toks[1].value),
					meta, self.sfz.filename))
			else:
				self.current_header.append_opcode(Opcode(
					opname, self.replace_defs(toks[1].value), meta))

	@v_args(meta=True)
	def start(self, arg1, arg2):
		"""
		Transformer function which handles the root of the sfz.
		"""

	def wonky_lark_args(self, arg1, arg2):
		"""
		When @v_args decorates a lark.Transformer function, lark passes parsed tokens
		and meta info to the function. Different versions of lark parser seem to pass
		the tokens and meta arguments in different order. This function fixes that.
		"""
		if isinstance(arg1, Meta):
			return arg1, arg2
		return arg2, arg1

	def replace_defs(self, var):
		"""
		Replace defined variable with the value that it has been defined as in the sfz.
		"""
		return re.sub(r'\$(\w+)', lambda v: self.sfz.defines[v.group(1)].value, var)

	def unquote(self, var):
		"""
		Remove quotes around a parsed value.
		"""
		for q in ["'", '"']:
			if var[0] == q and var[-1] == q:
				return var[1:-1]
		return var


class SFZ(_Header):
	"""
	Provides an object-oriented interface to an .sfz file.
	"""

	_parser = None

	def __init__(self, filename = None, defines = {}):
		"""
		filename: (str) Path to an .sfz file.

		Passing "defines" allows us to construct an SFZ which is an import, and use the
		defined variables from the parent SFZ.
		"""
		self.filename = filename
		self._parent = None
		self.defines = defines
		self.includes = []
		self._subheadings = []
		if filename is not None:
			if SFZ._parser is None:
				cache_file = os.path.join(user_cache_dir(), 'sfzen')
				grammar = os.path.join(os.path.dirname(__file__), 'res', 'sfz.lark')
				SFZ._parser = Lark.open(grammar, parser='lalr', propagate_positions=True, cache=cache_file)
			with open(filename) as f:
				tree = SFZ._parser.parse(f.read() + "\n")
			xformer = SFZXformer(self)
			xformer.transform(tree)

	def may_contain(self, header):
		return True

	def append_opcode(self, opcode):
		raise RuntimeError("Opcode outside of header")

	def append_subheader(self, subheading):
		self._subheadings.append(subheading)
		subheading.parent = self

	def __repr__(self):
		return 'SFZ "%s"' % os.path.basename(self.filename)

	def inherited_opcodes(self):
		return {}

	def headers(self):
		"""
		Returns a list of headers which are immediate children of this SFZ.
		"""
		return self._subheadings

	def samples(self):
		"""
		Generator which yields a Sample on each iteraration.
		"""
		for header in self._subheadings:
			yield from header.samples()

	def opcodes_used(self):
		"""
		Returns a set of the keys of all the opcodes used in this SFZ.
		"""
		return reduce(or_, [heading.opcodes_used() for heading in self._subheadings])

	def regions_for(self, lokey=None, hikey=None, lovel=None, hivel=None):
		"""
		Generator function which yields each region contained in this SFZ which matches
		the given criteria.
		For example, to get every region which plays Middle C at any velocity:
			sfz.regions_for(lokey = 60, hikey = 60)
		"""
		for region in self.regions():
			if region.is_triggerd_by(lokey, hikey, lovel, hivel):
				yield region

	def write(self, stream):
		"""
		Exports this SFZ to .sfz format.
		"stream" may be any file-like object, including sys.stdout.
		"""
		stream.write(f'{COMMENT_DIVIDER}// {self.filename}\n{COMMENT_DIVIDER}\n')
		for sub in self._subheadings:
			sub.write(stream)

	def dump(self):
		"""
		Print (to stdout) a concise outline of this SFZ.
		"""
		self._dump(self, 0)

	def _dump(self, obj, indent):
		print('  ' * indent, end="")
		print(repr(obj))
		if isinstance(obj, (_Header, SFZ)):
			for sub in obj.subheaders:
				self._dump(sub, indent + 1)


#  end sfzen/__init__.py
